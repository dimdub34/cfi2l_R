---
title: "<img src='img/R_logo.png' style='width: 200px' />"
author: "D. Dubois"
output: 
  revealjs::revealjs_presentation:
    css: custom.css
    reveal_options:
      slideNumber: true
---

```{r, include=FALSE}
source("script_source.R", local=knitr::knit_global())
```

--- 

**Contenu**

1. [Pr√©sentation et installation de R](#presentation)
2. [Pr√©sentation de RStudio](#rstudio)
3. [Structures de donn√©es](#structures)
4. [Pr√©paration d'un jeu de donn√©es](#preparation)
5. [Manipulation d'un jeu de donn√©es](#manipulation)
6. [Analyse d'un jeu de donn√©es](#analyse)
7. [Visualisation d'un jeu de donn√©es](#visualisation)
  

# 1. Pr√©sentation de R {#presentation}

--- 

- language pour l'analyse de donn√©es
- cr√©√© en 1996 par Ross Ihaka et Robert Gentleman
- d√©veloppement assur√© par des statisticiens rassembl√©s dans la **R Development Core Team**
- publi√© sous licence GNU GPL  

---

**Points forts**

- multiplateforme
- libre et gratuit
- language interpr√©t√©
- puissant avec possibilit√© d'extensions car fonctionne avec un syst√®me de packages
- cr√©ation de graphiques avanc√©s, exportables dans diff√©rents formats
- grande communaut√© d'utilisateurs tr√®s actifs

---

**Points faibles **

- plus un language de programmation qu'un logiciel, m√™me si des efforts sont faits pour d√©velopper de plus en plus d'interfaces graphiques "presse-bouton"
- pas simple d'acc√®s au d√©part, m√™me si des efforts sont faits pour simplifier les commandes et instructions
- language limit√© aux statistiques

---

**Installation**

- R : https://cran.r-project.org/
- RStudio : https://posit.co/

  
# 2. RStudio {#rstudio}

---

- Integrated Development Environment (IDE) pour R
- libre, gratuit et multiplateforme

<img src="img/rstudio_start.png" style="height: 500px" />

---

**3 zones**

- la console (interpr√©teur R) et le terminal
- les variables d'environnement et l'historique des commandes
- l'aide et la liste des packages

## La console

- permet d'interagir avec l'interpr√©teur R
- les fl√®ches haut et bas du clavier permettent de naviguer dans l'historique des commandes
- touche `Entr√©e` du clavier pour ex√©cuter la commande tap√©e

---

- pour stocker une valeur il faut cr√©er une variable
- le signe d'affectation en R est `<-`

```{r}
x <- 10
```

- on affecte la valeur 10 √† la variable x
- on appelle `x` dans la console pour afficher la valeur

```{r}
x
```

- les variables apparaissent dans l'onglet "Environnement", ce sont les objets en m√©moire pour la session en cours
- les commandes entr√©es dans la console apparaissent dans l'onglet "History"

---

- les noms de variable peuvent contenir des lettres, chiffres et les symboles "." et "_"
- ne peuvent pas commencer par un chiffre
- ne pas mettre d'accents
- sensible √† la casse (x et X sont deux variables diff√©rentes)

## Projet

- permet d√©finir le dossier dans lequel tous les fichiers du projet seront stock√©s (sources et sorties)
- √©vite les chemins absolus, utilisation des **chemins relatifs**
- pour cr√©er un nouveau projet : File/New Project
- soit cr√©er un nouveau dossier sur l'ordinateur, soit utiliser un dossier existant

File/New Project

![New Project](img/newProject.png)

## Scripts

- la console ne conserve pas le code une fois la session ferm√©e
- utilisation de scripts, qui permettent de stocker les commandes, et de les r√©utiliser
- pour cr√©er un script: File/New File/R Script
- c'est un fichier texte, enregistr√© avec l'extension `*.R`
- pour envoyer le code s√©lectionn√© dans la console soit `Run` soit `Ctrl + Entr√©e`
- `"#"` pour les commentaires

## Notebooks

- plus convivial que le script
- m√©lange de Markdown (html simplifi√©) et de code (avec la sortie juste en dessous)
- s'exporte en html ou pdf
- facilite le partage et la lecture du document

File/New File/R Notebook

<img src="img/newNotebook.png" style="height: 300px" />

---

- on peut changer title qui est le titre du notebook
- ne pas toucher √† output
- ce qui est apr√®s les trois tirets peut √™tre supprim√©, c'est un texte d'accueil standard
- un notebook est compos√© de texte au format markdown et de blocs de codes, appel√©s chunks
- insert/R pour ins√©rer un nouveau chunk ou `Ctrl + alt + i`
- dans le chunk, `Ctrl + Entr√©e` pour ex√©cuter la ligne courante et `Ctrl + Maj + Entr√©e` pour ex√©cuter tout le chunk

---

le r√©sultat de l'ex√©cution du chunk est affich√© juste en dessous

<img src="img/notebook1.png" style="height: 500px" />

---

A chaque enregistrement du notebook, R g√©n√®re le fichier html du notebook

<img src="img/notebook2.png" style="height: 500px" />

---

**Markdown**

- html simplifi√©
- utilis√© pour structurer le Notebook avec des titres, du texte en gras ou italique, des liens, des listes √† puces ou num√©rot√©es etc.
- RStudio propose un guide rapide : Help/Markdown Quick Reference

## Packages

- extensions des fonctionnalit√©s de base (R Core)
- d√©velopp√©s et maintenus par la communaut√©
- regroup√©s au sein du CRAN (Comprehensive R Archive Network)
- bouton `Install` de l'onglet `Packages`
- taper le nom du package et cliquer sur `Install`
- pour utiliser le package il faut le charger, avec `library(nom_du_package)`
- la commande `library()` est par convention plac√©e dans le premier chunk du notebook (ou en premi√®re ligne du script)

![Packages](img/packages.png)

---

üíª **Pratique**

- cr√©er un nouveau projet
- cr√©er un nouveau notebook
- installer les packages tidyverse et questionr puis les charger

```
install.packages("tidyverse")
install.packages("questionr")
library(tidyverse)
library(questionr)
```

# 3. Structures de donn√©es {#structures}

## Les types de donn√©es

- num√©riques : integer (entier) ou double (d√©cimaux)
- cha√Ænes de caract√®res : character
- bool√©ens : logical
- cat√©gorielles : factor
- NA : donn√©e manquante (Not Available)
- typeof(objet) pour conna√Ætre le type

```{r}
a <- "coucou"
print(typeof(a))
```

## Le vecteur

pour stocker plusieurs valeurs dans une variable (tableau unidimensionnel)

```{r}
tailles <- c(1.75, 1.54, 1.85, 1.92)
tailles
```

`c()` est une fonction qui concat√®ne les diff√©rentes valeurs dans le m√™me vecteur 

```{r}
(poids <- c(72, 59, 110, 95))
```

üí° *Dans un chunk, mettre des parenth√®ses autour du code ex√©cute le code et affiche le r√©sutat*

---

Un vecteur est un **objet index√©**, c'est √† dire que chaque √©l√©ment a un num√©ro d'ordre, appel√© index, qui permet de le retrouver.  
Pour acc√©der √† un √©l√©ment du vecteur, utilisation de l'op√©rateur \[\] avec dedans l'index de l'√©l√©ment souhait√©  
‚ö†Ô∏è **la num√©rotation commence √† 1**

```{r}
tailles
```

```{r}
tailles[2]
```

---

**plusieurs √©l√©ments via un vecteur d'index**

```{r}
tailles[2:3]
```

ou

```{r}
tailles[c(1, 3)]
```

---

Une op√©ration sur un vecteur s'applique √† **tous les √©l√©ments du vecteur**

```{r}
(tailles_cm <- tailles * 100)
```

```{r}
(imc <- poids / tailles ^ 2)
```

---

**Autres m√©thodes pour cr√©er un vecteur**  

Avec numeric(), character(), logical() pour des vecteurs vides.  
**Avec un entier en argument cela cr√©e le vecteur avec le nombre d'√©l√©ments correspondants**, avec des valeurs par d√©faut (0 pour numeric, "" pour character et FALSE pour logical)

```{r}
numeric(10)
```

**Avec l'op√©rateur '`:`'** : cr√©e un vecteur d'entiers qui se suivent

```{r}
1:10
```

---

Avec la fonction **`seq`** qui permet de cr√©er une s√©quence de nombres

```{r}
seq(from=1, to=10, by=2)
```

Avec la fonction **`rep`** qui permet de r√©p√©ter un vecteur

```{r}
rep(1:3, 2)
```

üí° **Remarques** : 

- Les fonctions `seq` et `rep` ont plusieurs arguments possibles, cf. leur documentation.
- Il existe des fonctions pour g√©n√©rer des vecteurs de donn√©es al√©atoires : `rnorm`, `runif`, `rbinom`, `rpois` etc.

---

üíª **Pratique**

A partir des donn√©es ci-dessous (4 foyers), calculer le revenu global du foyer puis le revenu par personne.

```{r, eval=F}
conjoint1 <- c(1200, 1180, 1750, 2100)
conjoint2 <- c(1450, 1870, 1690, 0)
nb_personnes <- c(4, 2, 3, 2)
```

---

**Fonctions utiles sur un vecteur**

on appelle une fonction avec son nom, suivi de parenth√®ses avec dedans z√©ro, un ou plusieurs arguments

- `?nom_fonction` (ou `help("nom_fonction")`) pour afficher l'aide de la fonction
- certaines fonctions ont des arguments obligatoires et des arguments facultatifs
- dans la signature de la fonction les arguments obligatoires n'ont pas de valeur par d√©faut, les arguments facultatifs en ont un
- par exemple la fonction `mean` a un argument obligatoire et un argument facultatif `na.rm`, qui permet de ne pas consid√©rer les valeurs manquantes (NA) pour calculer la moyenne

---

- length(v): renvoie la longueur de v (nombre d'√©l√©ments)
- mean(v) : renvoie la moyenne de v
- min(v), max(v) : renvoie le minimum (maximum) de v
- sum(v): renvoie la somme des valeurs de v
- range(v): renvoie un vecteur avec le min et le max
- unique(v): renvoie un vecteur √† partir de v mais en ayant supprim√© toutes les valeurs en double

```{r}
mean(tailles)
```

```{r}
min(tailles)
```

---

**Combinaison de vecteurs avec `rbind` et `cbind`**  

- `rbind` pour combiner des vecteurs en ligne
- `cbind` pour combiner des vecteurs en colonne

```{r}
(v1 <- c(1, 2, 3))
(v2 <- c(4, 5, 6))
```

**`rbind`**
```{r}
(rbind(v1, v2))
```

---

**`cbind`**
```{r}
(cbind(v1, v2))
```

---

**Calcul de moyennes sur un objet contenant plusieurs vecteurs : `rowMeans` et `colMeans`**

- `rowMeans` pour calculer la moyenne des lignes
- `colMeans` pour calculer la moyenne des colonnes

```{r}
(v1 <- seq(1, 10, by=2))
(v2 <- seq(2, 20, by=4))
(mat <- cbind(v1, v2))
```

--- 

**`rowMeans`**

```{r}
rowMeans(mat)
```

**`colMeans`**

```{r}
colMeans(mat)
```

üí° *Il existe aussi rowSums et colSums pour les sommes*

--- 

üíª **Pratique**

1. A partir des deux vecteurs ci-dessous, calculer la t√©mp√©rature moyenne et le total des pr√©cipitations

```{r, eval=F}
temperatures <- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)
precipitations <- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)
```

2. Avec les vecteurs de notes suivants (6 √©l√®ves) :

- faire afficher le min et le max dans chaque mati√®re
- calculer la moyenne g√©n√©rale de chaque √©l√®ve

```{r, eval=F}
python <- c(12, 16, 8, 18, 6, 10)
html <- c(14, 9, 13, 15, 17, 11)
bdd <- c(18, 11, 14, 10, 8, 12)
```

## Le dataframe

- tableau de donn√©es bi-dimensionnel (lignes, colonnes)
- chaque colonne est un vecteur de donn√©es
- les colonnes peuvent √™tre de type diff√©rent

Prenons comme exemple un jeu de donn√©es, `hdv2003`, fourni par le package `questionr` charg√© pr√©c√©demment. On charge le jeu de donn√©es avec la commande suivante

```{r}
data("hdv2003")
```

cela a pour effet de mettre le jeu de donn√©es dans l'environnement de travail (charg√© en m√©moire dans la session courante de R)  
*hdv2003* est un extrait de l‚Äôenqu√™te *Histoire de vie* r√©alis√©e par l‚ÄôINSEE en 2003. Il contient 2000 individus et 20 variables. 

Cliquer sur l'objet dans l'onglet environnement pour voir le tableau de donn√©es (on peut aussi appeler la fonction `View(hdv2003)`)

---

**Fonctions utiles**

- names(df) : affiche le nom des colonnes
- nrow(df) : renvoie le nombre de lignes
- ncol(df) : renvoie le nombre de colonnes
- dim(df) : renvoie un vecteur avec les dimensions, cad nrow et ncol
- names(df) : renvoie les noms des variables (colonnes)
- str(df) : affiche des infos sur le jeu de donn√©es - chaque variable avec son type et les premi√®res valeurs (si on clique sur la fl√®che bleu dans l'environnement cela affiche le contenu de str(df))
- head(df) : affiche les premi√®res lignes
- tail(df) : affiche les derni√®res lignes

```{r}
dim(hdv2003)
```

```{r}
names(hdv2003)
```

---

üíª **Pratique**

- Charger le jeu de donn√©es `hdv2003` du package `questionr`
- Appeler chacune des fonctions de "d√©couverte" sur le jeu de donn√©es `hdv2003`.


## La matrice

- tableau de donn√©es bi-dimensionnel (lignes, colonnes)
- chaque √©l√©ment est de m√™me type
- utilis√©e pour les calculs matriciels (calculs math√©matiques et op√©rations alg√©briques)

**Cr√©ation**

- `matrix(data, nrow, ncol, byrow=FALSE, dimnames=NULL)`
- `diag(n)` : matrice diagonale de taille n
- `diag(v)` : matrice diagonale avec les √©l√©ments de v sur la diagonale

```{r}
# matrice 3x3 avec des nombres de 1 √† 9
(matrice <- matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE))
```

---

**Op√©rations matricielles**

- `%*%` : produit matriciel
- `t(mat)` : transpos√©e de la matrice
- `solve(mat)` : inverse de la matrice
- `det(mat)` : d√©terminant de la matrice

## La liste

Structure de donn√©es qui peut contenir des √©l√©ments de types diff√©rents (vecteur, matrice, dataframe, autre liste, fonction)  

**Cr√©ation**

`list()`

```{r}
(liste <- list(nom="Dupont", prenom="Jean", age=45, taille=1.75))
```

---

```{r}
(ma_liste <- list(
  nombre = 42,
  texte = "Bonjour",
  vecteur = c(1, 2, 3),
  matrice = matrix(1:4, nrow = 2),
  logique = TRUE
))
```

# 4. Pr√©paration d'un jeu de donn√©es {#preparation}

---

- la premi√®re √©tape de traitement d'un jeu de donn√©es comprend le nettoyage, le recodage et la cr√©ation de nouvelles variables si besoin
- c'est l'activit√© qui prend le plus de temps lorsque l'on d√©couvre un jeu de donn√©es

---

**Utilisation des libraires du `tidyverse`**

Ensemble de librairies cr√©√©es pour faciliter le chargement, le nettoyage, le tri, l'analyse de donn√©es et les repr√©sentations graphiques  
`library(tidyverse)`

<img src="img/tidyverse.png" style="height: 200px" />

ggplot2 (visualisation), dplyr (manipulation des donn√©es), tidyr (mise en forme des donn√©es), purrr (programmation), readr (importation de donn√©es), tibble (tableaux de donn√©es), forcats (variables qualitatives),  stringr (cha√Ænes de caract√®res)

## Le Tibble

**Le `tibble` est la version moderne du dataframe**

- par rapport au dataframe, le tibble
  + n'a pas de nom de lignes
  + autorise des noms de colonnes avec espaces, caract√®res sp√©ciaux, nombres etc.
  + a un affichage par d√©faut sur qq lignes uniquement, avec des informations sur chaque variable
  + affiche un avertissement si on essaie d‚Äôacc√©der √† une colonne qui n‚Äôexiste pas
- les fonctions des librairies du tidyverse acceptent un dataframe en entr√©e, mais retournent un tibble

---

```{r}
as_tibble(hdv2003)
```

un tibble peut √©galement √™tre converti en dataframe avec la fonction as.data.frame()

## Lecture d'un jeu de donn√©es

- le csv est le format "standard" pour le stockage et le partage de donn√©es 
- c'est un fichier texte avec un s√©parateur de colonnes (le point-virgule, la virgule ou la tabulation)
- deux fonctions pour ouvrir un fichier csv:
  + read_csv : fichiers avec une virgule comme s√©parateur et le point en d√©cimale
  + read_csv2 : fichiers avec le point-virgule comme s√©parateur et la virgule en d√©cimale (comme en France par exemple)

üí° *RStudio propose une interface graphique pour l'import de donn√©es, en cliquant sur le bouton "Import Dataset" dans l'onglet Environment*

## Ecriture d'un jeu de donn√©es

Pour √©crire dans un fichier csv, il y a les fonctions write_csv et write_csv2

**S√©rialisation**

- pour sauvegarder des objets R au format R
- permet de sauvegarder plusieurs objets R dans un seul fichier (extension `*.Rdata`)
- fonction `save(objets, file="fichier.Rdata")`. 
- fonction `load("fichier.Rdata")` pour recharger les objets dans l'environnement de la session R

## Recodage des variables cat√©gorielles

### Renommer les modalit√©s

Fonction `fct_recode` (qui vient du package forcats)

```{r}
freq(hdv2003$qualif)
```

üí° *la fonction `freq`, du package `questionr` fournit des informations sur une variable cat√©gorielle : effectifs, pourcentages (avec et sans NA)*  
*`?questionr::freq` pour afficher l'aide*

---

üí° *Les modalit√©s d'une variable cat√©gorielle sont appel√© des `levels`*

```{r}
levels(hdv2003$qualif)
```

---

`fct_recode(vecteur, nouveau nom = ancien nom, ...)`

```{r}
hdv2003$qualif_grouped <- fct_recode(
  hdv2003$qualif,
  "Ouvrier" = "Ouvrier specialise",
  "Ouvrier" = "Ouvrier qualifie",
  "Interm" = "Technicien",
  "Interm" = "Profession intermediaire"
)
freq(hdv2003$qualif_grouped)
```
üí° le "$" permet d'afficher un vecteur d'un dataframe, mais permet aussi d'en cr√©er un nouveau, autrement dit de cr√©er une nouvelle variable dans le dataframe. 

---

Pour recoder une modalit√© en variable manquante utilisation de `NULL` comme nouveau nom

```{r}
hdv2003$qualif_grouped <- fct_recode(hdv2003$qualif_grouped, NULL="Autre")
freq(hdv2003$qualif_grouped)
```
```{r}
levels(hdv2003$qualif_grouped)
```

---

Pour coder les `NA` en modalit√©, fonction `fct_na_value_to_level`

```{r}
hdv2003$qualif_grouped <- fct_na_value_to_level(hdv2003$qualif_grouped)
levels(hdv2003$qualif_grouped)
```

---

une autre fa√ßon pour regrouper les modalit√©s est d'utiliser **`fct_collapse`**

```{r}
hdv2003$qualif_rec <- fct_collapse(
  hdv2003$qualif, 
  "Ouvrier"=c("Ouvrier specialise", "Ouvrier qualifie"), 
  "Interm"=c("Technicien", "Profession intermediaire"))
freq(hdv2003$qualif_rec)
```

üí° *Remarques* : 

1. `fct_other()` pour regrouper un ensemble de modalit√©s dans la cat√©gorie "Other"
2. `fct_lump()` pour regrouper les modalit√©s les moins fr√©quentes dans la cat√©gorie "Other"
3. interface graphique, propos√©e par `questionr`, √† partir de **`Addins`** puis **`Levels Recoding`**.

---

### R√©ordonner les modalit√©s

**`fct_relevel`**

```{r}
hdv2003$qualif_rec <- fct_relevel(
    hdv2003$qualif,
    "Cadre", "Profession intermediaire", "Technicien", 
    "Employe", "Ouvrier qualifie", "Ouvrier specialise",
    "Autre"
)
freq(hdv2003$qualif_rec)
```

---

üíª **Pratique**

1. dans les donn√©es hdv2003, recoder la variable `relig` afin d'obtenir
```
                              n    % val%
Pratiquant                  708 35.4 35.4
Appartenance                760 38.0 38.0
Ni croyance ni appartenance 399 20.0 20.0
Rejet                        93  4.7  4.7
NSP                          40  2.0  2.0
```

2. recoder la variable `nivetud` afin d'obtenir
```
                                          n    % val%
N'a jamais fait d'etudes                 39  2.0  2.1
√âtudes primaires                        427 21.3 22.6
1er cycle                               204 10.2 10.8
2eme cycle                              183  9.2  9.7
Enseignement technique ou professionnel 594 29.7 31.5
Enseignement superieur                  441 22.0 23.4
NA                                      112  5.6   NA
```

3. r√©-ordonner les modalit√©s de cette variable afin d'obtenir
```
                                         n    % val%
Enseignement superieur                  441 22.0 23.4
Enseignement technique ou professionnel 594 29.7 31.5
2eme cycle                              183  9.2  9.7
1er cycle                               204 10.2 10.8
√âtudes primaires                        427 21.3 22.6
N'a jamais fait d'etudes                 39  2.0  2.1
NA                                      112  5.6   NA
```

## Cr√©ation d'une variable cat√©gorielle

*√† partir d'une variable num√©rique*  

**`cut()`**

- cr√©ation de classes √† partir d'une variable num√©rique
- exemple : une variable de revenu
- l'argument `breaks` va permettre de d√©finir les intervalles des classes

`breaks=nombre` : l'interpr√©teur va cr√©er `nombre` classes de m√™me largeur

```{r}
hdv2003$age_classe <- cut(hdv2003$age, breaks=5)
freq(hdv2003$age_classe)
```

---

`breaks=vecteur` : l'interpr√©teur va cr√©er des classes en fonction des valeurs du vecteur

```{r}
hdv2003$age_classe2 <- cut(
    hdv2003$age, 
    breaks = c(18, 25, 35, 45, 55, 65, 100), 
    include.lowest = T  # pour inclure le 18
)
freq(hdv2003$age_classe2)
```
üí° le package *questionr* propose une interface graphique : Addins/Numeric range dividing

---

**`if_else`**

Cr√©er une variable cat√©gorielle √† deux modalit√©s en fonction des valeurs d'une variable num√©rique

`if_else(test, valeur si vrai, valeur si faux)`

```{r}
(v <- c(12, 14, 8, 16, 4))
if_else(v > 10, "Sup√©rieur √† 10", "Inf√©rieur √† 10")
```

---

`case_when` : √©tend `if_else` √† plusieurs conditions, sous la forme `condition ~ valeur`   
‚ö†Ô∏è les tests sont effectu√©s dans l'ordre, donc il faut aller du plus sp√©cifique au plus large

```{r}
hdv2003$statut <- case_when(
    hdv2003$age > 60 & hdv2003$sexe == "Homme" ~ "Homme de plus de 60 ans",
    hdv2003$age > 60 & hdv2003$sexe == "Femme" ~ "Femme de plus de 60 ans",
    TRUE ~ "Autre"
)

freq(hdv2003$statut)
```

Comme TRUE est toujours vrai toutes les autres combinaisons sont cod√©es "Autre".

---

üíª **Pratique**

1. d√©couper la variable heures.tv en classes afin d'obtenir le tableau de fr√©quences suivant

```
       n   %    val%
[0,1]  684 34.2 34.3
(1,2]  535 26.8 26.8
(2,4]  594 29.7 29.8
(4,6]  138  6.9  6.9
(6,12]  44  2.2  2.2
NA       5  0.2   NA
```

2. avec `if_else`, cr√©er la variable `cinema_bd` qui groupe les personnes qui vont au cin√©ma et qui lisent des bd. Les autres sont mis dans "Autre". Le r√©sultat attendu est
```
               n    % val%
Autre        1971 98.6 98.6
Cin√©ma et BD   29  1.5  1.5
```

3. avec `case_when` cr√©er la variable `genre_fratrie` ayant les modalit√©s : Homme avec plus de 2 fr√®res et soeurs, Femme avec plus de 2 fr√®res et soeurs, Autre. Le r√©sulat attendu est
```
                                         n    % val%
Autre                                  1001 50.0 50.0
Femme avec plus de 2 fr√®res et soeurs  546  27.3 27.3
Homme avec plus de 2 fr√®res et soeurs  453  22.7 22.7
```

## Mise en forme des donn√©es

Pour pouvoir manipuler les donn√©es il faut qu'elles soient bien rang√©es, ie "**tidy**", notamment:

- chaque variable est dans une colonne unique
- chaque colonne contient une unique variable
- chaque ligne correspond √† une observation pour chaque variable
- les cellules du tableau repr√©sentent les valeurs de chaque observation pour chaque variable
  
![tidy](img/tidy_theory.png)

---

Exemple de donn√©es non tidy : Population de 3 pays sur 4 ann√©es

![Data non tidy](img/data_non_tidy.png)

pour que ce soit tidy il faudrait 

- une observation par ligne
- une variable ann√©e et une variable population

---

Le dataset serait alors

![Data tidy](img/data_tidy.png)

---

Fonction `pivot_longer` pour cr√©er un dataset "plus long" c'est √† dire avec plus de lignes

```{r, echo=F}
tidy_ex <- data.frame(country=c("Belgium", "France", "Germany"), `2002`=c(10311970, 59925035, 82350671), `2007`=c(10392226, 61083916, 82400996))
colnames(tidy_ex)[2:3] <- c("2002", "2007")
print(tidy_ex)
```

les colonnes 2002 et 2007 devraient √™tre dans une colonne "ann√©e" et les valeurs dans une colonne "population"

```{r}
pivot_longer(data=tidy_ex, cols=c("2002", "2007"), names_to="annee", values_to="population")
```

---

Fonction `pivot_wider` pour √† l'inverse cr√©er un dataset "plus large", c'est √† dire avec plus de colonnes

```{r, echo=F}
tidy_ex1 <- data.frame(country=c(rep("Belgium", 4), rep("France", 4)), continent=rep("Europe", 8), year=rep(c(rep(2002, 2), rep(2007, 2)), 2),                                variable=rep(c("lifeExp", "pop"), 4), value=c(78.320, 10311970.000, 79.441, 10392226.000, 79.590, 59925035.000, 80.657, 61083916.000))
tidy_ex1
```

la colonne variable devrait √™tre divis√©e en deux variables lifeExp et pop

```{r}
pivot_wider(data=tidy_ex1, names_from=variable, values_from=value)
```

# 5. Manipulation d'un jeu de donn√©es {#manipulation}

---

le package `dplyr` du `tidyverse` propose 6 fonctions : `slice, filter, select, rename, arrange et mutate`

Pour les exemples, utilisation des datasets du package `nycflights23` (donn√©es des vols de d√©part de 3 a√©roports de New-York en 2023)  

```
install.packages("nycflights23")
library(nycflights23)
```

```{r, eval=F}
data("flights")
data("airports")
data("airlines")
```

---

### slice

Permet de s√©lectionner des lignes du dataset par leur index

```{r}
slice(airports, 2:8)
```

---

### filter

Permet de s√©lectionner des lignes du dataset en fonction de crit√®res  

Tous les vols du mois de janvier

```{r}
filter(flights, month==1)
```

---

**Plusieurs conditions**    

Tous les vols qui ont entre 10 et 15 minutes de retard au d√©collage

```{r}
filter(flights, dep_delay >= 10, dep_delay <= 15)
```

üí° *Remarques* : 

1. `dplyr` combine automatiquement avec l'op√©rateur `&` les conditions s√©par√©es par une virgule, donc `filter(flights, dep_delay >= 10, dep_delay <= 15)` est √©quivalent √† `filter(flights, dep_delay >= 10 & dep_delay <= 15)`.
2. pour le `OU` par contre, il faut forc√©ment `filter(flights, dep_delay < 10 | dep_delay > 15)`

---

```{r}
filter(flights, month == 1, dep_delay >= 10, dep_delay <= 15)
```

---

**Possible de passer le r√©sultat d'une fonction dans la condition**   

Les vols avec la distance la plus longue

```{r}
filter(flights, distance == max(distance))
```

---

### select

Permet de s√©lectionner les colonnes du dataset  
S√©lection des colonnes latitude et longitude

```{r}
select(airports, lat, lon)
```

---

Un "`-`" devant le nom de colonne affiche toutes les colonnes sauf celle avec le moins

```{r}
select(airports, -lat)
```

---

Possible de renommer les variables pour l'affichage

```{r}
select(airports, latitude=lat, longitude=lon)
```

---

`select` peut prendre comme argument des √©l√©ments permettant une s√©lection selon des crit√®res

```{r}
select(flights, starts_with("dep_"))
```

il y a aussi *ends_with*, *contains* et *matches*

## rename

Pour renommer les colonnes  
nouveau nom = ancien nom  
si le nouveau nom (ou l'ancien) comporte un ou des espace(s) il faut mettre entre guillemets

```{r}
rename(airports, longitude=lon, latitude=lat, altitude=alt)
```

## arrange

Pour ordonner le dataset selon les valeurs d'une ou plusieurs colonnes

```{r}
arrange(flights, dep_delay)
```

--- 

Fonction `desc()` pour inverser l'ordre (d√©croissant)

```{r}
arrange(flights, desc(dep_delay))
```

---

Plusieurs crit√®res

```{r}
arrange(flights, month, desc(dep_delay))
```

## mutate

Pour cr√©er de nouvelles variables

```{r}
head(select(flights, air_time), 5)
```
Cr√©ation d'une variable `air_time_hours` 

```{r}
flights <- mutate(flights, air_time_hours = air_time / 60)
head(select(flights, air_time, air_time_hours), 5)
```

---

Plusieurs nouvelles variables d'un coup

```{r}
flights <- mutate(
    flights,
    distance_km = distance / 0.62137,
    vitesse = distance_km / air_time_hours
)
select(flights, air_time_hours, distance_km, vitesse)
```

## Le pipe

Les actions vues pr√©c√©demment peuvent √™tre encha√Æn√©es gr√¢ce au `pipe` c'est √† dire l'envoi du r√©sultat de l'action pr√©c√©dente comme premier argument de l'action suivante.  
C'est l'op√©rateur `|>` qui joue ce r√¥le

```{r}
flights |>
  filter(dep_delay >= 10 & dep_delay <= 15) |>
  arrange(desc(dep_delay)) |>
  select(flight, origin, dest, dep_delay, air_time_hours, distance_km, vitesse) |>
  head(5)
```

---

‚ö†Ô∏è Attention les actions s'encha√Ænent (pipeline) mais rien n'est conserv√©. 
Pour enregistrer le r√©sultat dans un objet il faut commencer par une affectation (`<-`)

```{r}
delays <- flights |>
  filter(dep_delay >= 10 & dep_delay <= 15) |>
  arrange(desc(dep_delay)) |>
  select(flight, origin, dest, dep_delay, air_time_hours, distance_km, vitesse)
```

Le r√©sultat du pipeline sera stock√© dans l'objet delays.

---

üíª **Pratique**

1. afficher les lignes 100 √† 105 du dataset flights
2. afficher les vols du mois de juillet 2023
3. afficher les vols qui ont eu un retard (variable arr_delay) compris entre 5 et 15 minutes. Le r√©sultat doit √™tre affich√© par ordre d√©croissant
4. selectionner les colonnes name, lat et lon du dataset airports et renommer lat et lon en latitude et longitude
5. dans le dataset airports, cr√©er une nouvelle variable alt_metres qui contient l'altitude en m√®tres (conversion de pieds en m√®tres en divisant la variable alt par 3.28)

## group_by

Permet de grouper les donn√©es puis d'appliquer une fonction √† ces donn√©es group√©es  

Grouper les donn√©es par mois et affiche le premier index (combinaison group_by et slice)

```{r}
flights |> group_by(month) |> slice(1)
```

---

Grouper les donn√©es par compagnie, calculer le delay moyen et le mettre dans une variable mean_delay (combinaison group_by et mutate)

```{r}
flights |>
  group_by(carrier) |>
  mutate(mean_delay = mean(dep_delay, na.rm=T)) |>
  select(carrier, origin, dest, mean_delay)
```

--- 

Grouper les donn√©es par mois, et afficher les vols qui ont le d√©lai maximum (combinaison group_by et filter)

```{r}
flights |>
  group_by(month) |>
  filter(dep_delay == max(dep_delay, na.rm=T)) |>
  select(month, origin, dest, carrier, dep_delay) |>
  arrange(month)
```

## summarise

Permet d'agr√©ger une information

```{r}
flights |>
  summarise(
    retard_depart=mean(dep_delay, na.rm=T),
    retard_arrivee=mean(arr_delay, na.rm=T)
  )
```

---

Utilis√© avec `group_by`, `summarise` permet d'agr√©ger une information sur des donn√©es group√©es  

Le retard moyen de chaque compagnie et ordonn√© du plus grand retard moyen au plus petit

```{r}
flights |>
  group_by(carrier) |>
  summarise(retard_depart=mean(dep_delay, na.rm=T)) |>
  arrange(desc(retard_depart))
```

--- 

L'argument `n=n()` dans `summarise` donne le nombre d'observations utilis√©es pour le calcul

```{r}
flights |>
  group_by(carrier) |>
  summarise(
    retard_depart=mean(dep_delay, na.rm=T),
    n=n()
  )|>
  arrange(desc(retard_depart))
```

--- 

Possible de grouper les donn√©es selon plusieurs variables  
On groupe les donn√©es par mois et par destination et on compte le nombre de vols

```{r}
flights |> 
  group_by(month, dest) |>
  summarise(n=n()) |>
  arrange(desc(n))
```

---

Utilisation d'une donn√©e cr√©√©e par `summarise` pour cr√©er une nouvelle variable avec `mutate`

```{r}
flights |> 
  group_by(month, dest) |>
  summarise(n=n()) |>
  mutate(pourcentage=n/sum(n) * 100) |>
  arrange(desc(pourcentage))
```

---

üíª **Pratique**

1. afficher le nombre de vols par mois et afficher le r√©sultat par ordre croissant du nombre de vols
2. calculer le nombre de vols √† destination de Los Angeles (code LAX) pour chaque mois de l'ann√©e
3. calculer le nombre de vols par mois et par destination et afficher uniquement le max
4. calculer le nombre de vols par mois et cr√©er une colonne qui affiche le pourcentage que cela repr√©sente sur les vols annuels


# 6. Analyse d'un jeu de donn√©es {#analyse}

## Analyse univari√©e

- analyse d'une seule variable
- d√©pend de son type: 
  + quantitative (comme l'√¢ge ou le revenu par exemple)
  + qualitative / cat√©gorielle (nombre limit√© de valeurs possibles, comme le genre ou la profession par exemple)

---

### Variable quantitative

- on va regarder sa distribution avec des indicateurs simples : minimum, maximum, moyenne, m√©diane, variance, √©cart-type
- les fonctions sont `min(), max(), range(), mean(), median(), var(), sd()`
- on peut aussi calculer les quartiles avec la fonction quantile

```{r}
quantile(hdv2003$age)
```

on peut directement demander un quartile pr√©cis avec l'argument prob

```{r}
quantile(hdv2003$age, prob=0.25)
```

la fonction summary() donne toutes ces informations d'un coup

```{r}
summary(hdv2003$age)
```

---

### Variable cat√©gorielle

La fonction `table()` compte le nombre d'observations de chaque modalit√©

```{r}
table(hdv2003$sexe)
```
```{r}
table(hdv2003$qualif)
```

--- 

pour comptabiliser les valeurs manquantes il faut ajouter l'argument `useNA="always"`

```{r}
table(hdv2003$qualif, useNA="always")
```

üí° *La fonction summary() appliqu√©e sur une variable qualitative appelle en fait la fonction table()*  

---

Pour des pourcentages, la fonction `prop.table()` avec en argument l'objet renvoy√© par `table()`

```{r}
prop.table(table(hdv2003$qualif, useNA="always")) * 100
```

En 2 √©tapes

```{r}
ma_table <- table(hdv2003$qualif, useNA="always")
prop.table(ma_table) * 100
```

---

- la librairie *questionr* propose la fonction `freq()`
- la derni√®re colonne est sans comptabiliser les NA

```{r}
freq(hdv2003$qualif)
```

üí°`freq()` √† qq param√®tres utiles (valid=F pour ne pas afficher la colonne valid, total=T pour afficher une ligne avec le total, et sort="dec" pour afficher du plus grand au plus petit)

```{r}
freq(hdv2003$qualif, valid=F, total=T, sort="dec")
```

---

üíª **Pratique**

1. faire une analyse de la variable heures.tv
2. faire une analyse de la variable trav.imp

## Analyse bivari√©e

- √©tudier la relation entre 2 variables
- l'analyse va d√©pendre du type des variables: 
  + qualitative-qualitative
  + qualitative-quantitative
  + quantitative-quantitative

---

### Deux variables qualitatives

Tableau crois√©, avec la fonction `table()` en lui passant deux vecteurs

```{r}
(tb_prof_genre <- table(hdv2003$qualif, hdv2003$sexe))
```

---

- en pourcentages avec `prop.table()`
- margin indique l'axe (lignes=1, colonnes=2) par lequel il faut calculer les pourcentages

```{r}
prop.table(tb_prof_genre, margin=1) * 100
```

üí° la fonction `round()` permet de fixer le nombre de d√©cimales, 2 ci-dessous

```{r}
round(prop.table(tb_prof_genre, margin=1) * 100, 2)
```

---

Changement d'axe pour le calcul: r√©partition des professions pour chaque genre

```{r}
round(prop.table(table(hdv2003$qualif, hdv2003$sexe), margin=2) * 100, 2)
```

---

`questionr` propose `lprop` et `cprop`, avec en plus le total et un formatage par d√©faut d'une d√©cimale

```{r}
lprop(tb_prof_genre)
```

üí° qq param√®tres utiles: ajout de %, des effectifs, et changement du nombre de d√©cimales

```{r}
lprop(tb_prof_genre, percent=T, n=T, digits=2)
```

---

**Test statistique**

- test d'ind√©pendance du $\chi^2$ pour savoir si la r√©partition homme/femme dans chaque m√©tier est proche ou non. 
- hypoth√®se $H_0$ : la profession et le genre sont deux variables ind√©pendantes

```{r}
chisq.test(tb_prof_genre)
```

- `X-squared` est la valeur de la statistique du $\chi^2$, c'est une mesure de distance entre le tableau donn√© et le tableau th√©orique si les deux variables √©taient ind√©pendantes
- `df` est le nombre de degr√©s de libert√© (ddl=(nombre de lignes - 1) x (nombre de colonnes  -1))
- `p-value` est la probabilit√© que l'observe $H_0$. Ici la p-value est inf√©rieure √† 5% le seuil standard, donc on rejette $H_0$, i.e. on en d√©duit que les deux variables ne sont pas ind√©pendantes.

--- 

üíª **Pratique**

Faire l'analyse de l'importance du travail (variable trav.imp) en fonction du genre

---

### Une variable qualitative et une variable quantitative

D√©terminer si les valeurs de la variable quantitative se r√©partissent diff√©remment ou non selon les modalit√©s de la variable qualitative

```{r}
hdv2003 |>
  group_by(sport) |>
  summarise(mean_age=mean(age), sd_age=sd(age))
```

---

**Test statistique**

- tester si l'√¢ge moyen est statistiquement diff√©rent entre les sportifs et les non-sportifs 
- si la variable quantitative suit un loi normale test param√©trique de student, sinon test non-param√©trique de Mann-Whitney
- test de normalit√© : le test de shapiro - $H_0$ la distribution suit une loi normale

```{r}
shapiro.test(hdv2003$age)
```

la p-value est inf√©rieure √† 5% donc on rejette $H_0$, il faut utiliser un test non-param√©trique  

---

Test de Mann-Whitney : wilcox.test avec argument paired=F car les deux √©chantillons (sportifs et non-sportifs) sont ind√©pendants (ce ne sont pas les m√™mes personnes)

```{r}
wilcox.test(hdv2003$age ~ hdv2003$sport, paired=F)
```

Test de Student ($H_0$: l'√¢ge moyen des deux modalit√©s n'est pas diff√©rent)

```{r}
t.test(hdv2003$age ~ hdv2003$sport)
```

dans les deux tests la p-value est inf√©rieure √† 5% donc $H_0$ est rejet√©e, autrement dit l'√¢ge moyen des sportifs est significativement inf√©rieur √† celui des non-sportifs

---

üíª **Pratique**

Analyser la relation entre le nombre d'heures de t√©l√© (heures.tv) et le statut d'occupation (occup)  

---

### Deux variables quantitatives

chargement d'un nouveau jeu de donn√©es, propos√© par *questionr*  
Il s'agit de donn√©es sur les communues fran√ßaises de plus de 2000 habitants

```{r, eval=F}
data("rp2012")
```

---

<img src="img/rp2012.png" height="500">

---

#### Coefficient de corr√©lation

Pour d√©terminer la relation entre deux variables num√©riques, calcul du coefficient de corr√©lation.  
Le coefficient de corr√©lation varie entre -1 et 1, il mesure la force et le sens de la relation entre deux variables.  
Un coefficient proche de -1 indique une relation n√©gative (lorsque l'une des variables augmente l'autre diminue), et un coefficient proche de 1 indique une relation positive (les deux variables vont dans le m√™me sens).

Si la relation est lin√©aire utilisation du coefficient de corr√©lation de Pearson (m√©thode par d√©faut)

```{r}
cor(rp2012$cadres, rp2012$dipl_sup, method="pearson")
```

Le coefficient indique qu'il y a une forte relation lin√©aire positive. 

---

Test statistique correspondant avec la fonction *cor.test()*    
$H_0$ : le coefficient est √©gal √† 0

```{r}
cor.test(rp2012$cadres, rp2012$dipl_sup, method="pearson")
```

Rejet de $H_0$, la corr√©lation est significativement diff√©rente de 0.

---

Si la relation n'est pas lin√©aire il faut utiliser la m√©thode des rangs de Spearman

```{r}
cor(rp2012$cadres, rp2012$dipl_sup, method="spearman")
```

---

#### R√©gression lin√©aire

Si la relation entre deux variables est lin√©raire, estimation de la regression lin√©aire, c'est √† dire des param√®tres de la droite qui repr√©sente au mieux le nuage de points.

```{r}
lm(rp2012$cadres ~ rp2012$dipl_sup)
```

La constante est √©gale √† 0.9217 et la pente de la droite √† 1.0816

---

Si la sortie de la fonction `lm` est plac√©e en argument de la fonction `summary` alors davantage d'informations

```{r}
summary(lm(rp2012$cadres ~ rp2012$dipl_sup))
```

---

üíª **Pratique**

Analyser la relation entre les variables dipl_aucun (proportion de personnes sans dipl√¥mes) et proprio


# 7. Visualisation d'un jeu de donn√©es {#visualisation}

---

dataset pour travailler : un sous-ensemble des donn√©es rp2012

```{r}
rp <- rp2012 |> filter(departement %in% c("Oise", "Rh√¥ne", "Hauts-de-Seine", "Loz√®re", "Bouches-du-Rh√¥ne"))
head(rp)
```

---

**Fonctionnement g√©n√©ral de ggplot2**

- initialisation de la fonction graphique avec `ggplot()`
- ajout des graphiques avec `geom_` (histogramme, nuage de points, boxplot, barres, courbes, ...)
- personnalisation des graphiques avec des arguments dans les fonctions `geom_` et `aes()`
- la fonction `aes()` permet de mapper les variables du dataset aux √©l√©ments du graphique

## Une variable

### Histogramme

**`geom_histogram`**

```{r, fig.height=4}
ggplot(data=rp) +
  geom_histogram(aes(x=cadres))
```

---

Personnalisation des classes avec breaks

```{r, fig.height=4}
ggplot(data=rp) +
  geom_histogram(aes(x=cadres), breaks=seq(0, 60, 10))
```


---

### Bo√Æte √† moustaches

**`geom_boxplot`**

```{r, fig.height=4}
ggplot(data=rp) +
  geom_boxplot(aes(x=departement, y=maison))
```

---

L'argument varwidth permet que la largeur de la box soit proportionnelle au nombre d'observations

```{r, fig.height=4}
ggplot(data=rp) +
  geom_boxplot(aes(x=departement, y=maison), varwidth=T)
```

---

### Barres

**`geom_bar`**

```{r, fig.height=4}
ggplot(data=rp) +
  geom_bar(aes(x=departement))
```

---

**`geom_col`** pour un graphique en colonnes avec des valeurs personnalis√©es (ici le pourcentage)

```{r, fig.height=4}
rp |> 
  group_by(departement) |> 
  summarise(n=n()) |> 
  mutate(pourcent=n/sum(n) * 100) |>
  ggplot() + 
  geom_col(aes(x=departement, y=pourcent))
```

---

### Camembert

**`geom_col` avec coordonn√©es polaires**  

ggplot2 ne propose pas de graphique camembert, mais on peut le faire avec coordonn√©es polaires  

```{r, fig.height=4}
rp |> 
  group_by(departement) |> 
  summarise(n=n()) |> 
  mutate(pourcent=n/sum(n) * 100) |>
  ggplot() + 
  geom_col(aes(x="", y=pourcent, fill=departement)) + 
  coord_polar("y", start=0)
```

## Deux variables

### Nuage de points

**`geom_point`** avec 2 arguments dans `aes()`, la variable x et la variable y

```{r, fig.height=4}
ggplot(data=rp) +
  geom_point(aes(x=dipl_sup, y=cadres))
```

---

**Ajout d'une droite de r√©gression avec `geom_smooth`** en plus de `geom_point`

üí° Si plusieurs `geom` utilisent les m√™mes √©l√©ments dans `aes`, la fonction `aes()` peut √™tre appel√©e dans `ggplot`

```{r, fig.height=4}
ggplot(rp, aes(x=dipl_sup, y=cadres)) +
  geom_point() + geom_smooth(method ="lm", color="red")
```

---

### Courbes

chargement d'un jeu de donn√©es du package ggplot2 : economics

```{r, eval=F}
data("economics")
```

```{r}
head(economics)
```

---

**`geom_line`** 

```{r, fig.height=4}
chom <- economics |> select(date, unemploy)
ggplot(chom) + 
  geom_line(aes(x=date, y=unemploy))
```

üí° Pour ajouter plusieurs courbes dans le graphique, plusieurs appels √† `geom_line` (avec "+" entre chaque)

## Trois ou quatre variables

**Le mappage**

- Associer un des attributs du graphique (couleur, taille) √† une variable
- Permet de visualiser une troisi√®me dimension (voire une quatri√®me)
- Le mappage se fait dans l'appel de la fonction `aes()`

```{r, fig.height=4}
ggplot(rp) +
  geom_point(aes(x = dipl_sup, y = cadres, color = departement))
```

---

Ajout d'une 4√®me dimension avec la taille des points, ici la population totale de la commune

```{r, fig.height=4}
ggplot(rp) +
  geom_point(aes(x=dipl_sup, y=cadres, color=departement, size=pop_tot))
```

---

## Le faceting

D√©composer un graphique en plusieurs, selon les modalit√©s d'une ou plusieurs variables cat√©gorielles

```{r, fig.height=4}
ggplot(rp) +
  geom_histogram(aes(x=cadres), breaks=seq(0, 60, 10)) +
  facet_wrap(vars(departement))
```

---

```{r, fig.height=4}
ggplot(rp) +
  geom_point(aes(x=dipl_sup, y=cadres, color=proprio, size=pop_tot)) + 
  facet_wrap(vars(departement))
```

## Personnalisation des graphiques  

`scale_x_continuous` et `scale_y_continuous` pour les axes x et y de donn√©es quantitatives

```{r, fig.height=4}
ggplot(data=rp) +
  geom_point(aes(x=dipl_sup, y=cadres)) +
  scale_x_continuous("Dipl√¥mes sup√©rieurs", limits=c(0, 60)) +
  scale_y_continuous("Cadres", limits=c(0, 60))
```

---

`scale_x_discrete` et `scale_y_discrete` pour les variables cat√©gorielles

```{r, fig.height=4}
ggplot(rp) +
  geom_bar(aes(x = departement)) +
  scale_x_discrete("D√©partement")
```

---

üí° le package `esquisse` propose un Addins pour faire les graphiques `Addins/ggplot2 builder`

---

üíª **Pratique**

Avec le dataset rp2012

1. un nuage de points x=dipl_aucun et y=ouvr, avec titre des axes, et points en bleu
2. m√™me graphique que pr√©c√©demment mais avec un mappage de couleur selon la r√©gion
3. boxplot: distribution de la variable proprio par rapport √† la taille de departement (pop_cl)
4. nuage de points avec en x=dipl_sup et y=cadres avec un graphique par r√©gion (facet_wrap)
5. boxplot: distribution du pourcentage moyen de propri√©taires par d√©partement au sein de chaque r√©gion


# Sources

- un ouvrage complet sur l'analyse de donn√©es avec R [ici](https://larmarange.github.io/analyse-R/analyse-R.pdf)
- le cours de Julien Barnier (package `questionr`) accessible en ligne [ici](https://juba.github.io/tidyverse/index.html)
- le site https://www.tidyverse.org/
- le site [R for data science](https://r4ds.had.co.nz/index.html)
- le site de ggplot2 http://ggplot2.tidyverse.org/reference/
- des exemples de graphiques avec ggplot2 : http://www.cookbook-r.com/Graphs/
